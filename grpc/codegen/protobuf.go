package codegen

import (
	"fmt"
	"strconv"
	"strings"

	"goa.design/goa/codegen"
	"goa.design/goa/expr"
)

// ProtoBufMessageName returns the protocol buffer message name of the given
// attribute type.
func ProtoBufMessageName(att *expr.AttributeExpr, s *codegen.NameScope) string {
	return ProtoBufFullMessageName(att, "", s)
}

// ProtoBufFullMessageName returns the protocol buffer message name of the
// given user type qualified with the given package name if applicable.
func ProtoBufFullMessageName(att *expr.AttributeExpr, pkg string, s *codegen.NameScope) string {
	switch actual := att.Type.(type) {
	case expr.UserType:
		n := s.HashedUnique(actual, typeName(actual.Name()), "")
		if pkg == "" {
			return n
		}
		return pkg + "." + n
	case expr.CompositeExpr:
		return ProtoBufFullMessageName(actual.Attribute(), pkg, s)
	default:
		panic(fmt.Sprintf("data type is not a user type %T", actual)) // bug
	}
}

// ProtoBufMessageDef returns the protocol buffer code that defines a message
// which matches the data structure definition (the part that comes after
// `message foo`). The message is defined using the proto3 syntax.
func ProtoBufMessageDef(att *expr.AttributeExpr, s *codegen.NameScope) string {
	switch actual := att.Type.(type) {
	case expr.Primitive:
		return ProtoBufNativeMessageTypeName(actual)
	case *expr.Array:
		return "repeated " + ProtoBufMessageDef(actual.ElemType, s)
	case *expr.Map:
		return fmt.Sprintf("map<%s, %s>",
			ProtoBufMessageDef(actual.KeyType, s),
			ProtoBufMessageDef(actual.ElemType, s))
	case *expr.Object:
		var ss []string
		ss = append(ss, " {")
		for _, nat := range *actual {
			var (
				fn   string
				fnum uint64
				typ  string
				desc string
			)
			{
				fn = fieldName(nat.Name, false)
				fnum = rpcTag(nat.Attribute)
				typ = ProtoBufMessageDef(nat.Attribute, s)
				if nat.Attribute.Description != "" {
					desc = codegen.Comment(nat.Attribute.Description) + "\n\t"
				}
			}
			ss = append(ss, fmt.Sprintf("\t%s%s %s = %d;", desc, typ, fn, fnum))
		}
		ss = append(ss, "}")
		return strings.Join(ss, "\n")
	case expr.UserType:
		return ProtoBufMessageName(att, s)
	default:
		panic(fmt.Sprintf("unknown data type %T", actual)) // bug
	}
}

// ProtoBufTypeRef returns the Go code that refers to the Go type generated
// from the protocol buffer type which matches the given attribute type.
func ProtoBufTypeRef(att *expr.AttributeExpr, s *codegen.NameScope) string {
	return "*" + ProtoBufMessageName(att, s)
}

// ProtoBufFullTypeRef returns the Go code that refers to the Go type generated
// from the protocol buffer type which matches the given attribute type defined
// in the given package if a user type.
func ProtoBufFullTypeRef(att *expr.AttributeExpr, pkg string, s *codegen.NameScope) string {
	return "*" + ProtoBufFullMessageName(att, pkg, s)
}

// ProtoBufify makes a valid protocol buffer identifier out of any string.
// It does that by removing any non letter and non digit character and by
// making sure the first character is a letter or "_". ProtoBufify produces a
// "CamelCase" version of the string.
//
// If firstUpper is true the first character of the identifier is uppercase
// otherwise it's lowercase.
func ProtoBufify(str string, firstUpper bool) string {
	// Optimize trivial case
	if str == "" {
		return ""
	}

	// Remove optional suffix that defines corresponding transport specific
	// name.
	idx := strings.Index(str, ":")
	if idx > 0 {
		str = str[:idx]
	}

	str = codegen.CamelCase(str, firstUpper)
	if str == "" {
		// All characters are invalid. Produce a default value.
		if firstUpper {
			return "Val"
		}
		return "val"
	}
	return fixReservedProtoBuf(str)
}

// ProtoBufNativeMessageTypeName returns the protocol buffer built-in type
// corresponding to the given primitive type. It panics if t is not a
// primitive type.
func ProtoBufNativeMessageTypeName(t expr.DataType) string {
	switch t.Kind() {
	case expr.BooleanKind:
		return "bool"
	case expr.IntKind:
		return "sint32"
	case expr.Int32Kind:
		return "sint32"
	case expr.Int64Kind:
		return "sint64"
	case expr.UIntKind:
		return "uint32"
	case expr.UInt32Kind:
		return "uint32"
	case expr.UInt64Kind:
		return "uint64"
	case expr.Float32Kind:
		return "float"
	case expr.Float64Kind:
		return "double"
	case expr.StringKind:
		return "string"
	case expr.BytesKind:
		return "bytes"
	default:
		panic(fmt.Sprintf("cannot compute native protocol buffer type for %T", t)) // bug
	}
}

// ProtoBufNativeGoTypeName returns the Go type corresponding to the given
// primitive type generated by the protocol buffer compiler after compiling
// the ".proto" file.
func ProtoBufNativeGoTypeName(t expr.DataType) string {
	switch t.Kind() {
	case expr.BooleanKind:
		return "bool"
	case expr.IntKind:
		return "int32"
	case expr.Int32Kind:
		return "int32"
	case expr.Int64Kind:
		return "int64"
	case expr.UIntKind:
		return "uint32"
	case expr.UInt32Kind:
		return "uint32"
	case expr.UInt64Kind:
		return "uint64"
	case expr.Float32Kind:
		return "float32"
	case expr.Float64Kind:
		return "float64"
	case expr.StringKind:
		return "string"
	case expr.BytesKind:
		return "[]byte"
	default:
		panic(fmt.Sprintf("cannot compute native protocol buffer type for %T", t)) // bug
	}
}

// typeName returns the CamelCase version of the given string.
func typeName(str string) string {
	return ProtoBufify(str, true)
}

// fieldName returns the snake_case version of the given string.
// If upper is true it converts the string to all upper case.
func fieldName(str string, upper bool) string {
	str = codegen.SnakeCase(ProtoBufify(str, false))
	if upper {
		str = strings.ToUpper(str)
	}
	return str
}

// rpcTag returns the unique numbered RPC tag from the given attribute.
func rpcTag(a *expr.AttributeExpr) uint64 {
	var tag uint64
	if t, ok := a.Meta["rpc:tag"]; ok {
		tn, err := strconv.ParseUint(t[0], 10, 64)
		if err != nil {
			panic(err) // bug (should catch invalid field numbers in validation)
		}
		tag = tn
	}
	return tag
}

// fixReservedProtoBuf appends an underscore on to protocol buffer reserved
// keywords.
func fixReservedProtoBuf(w string) string {
	if reservedProtoBuf[w] {
		w += "_"
	}
	return w
}

var (
	// reserved protocol buffer keywords and package names
	reservedProtoBuf = map[string]bool{
		// types
		"bool":     true,
		"bytes":    true,
		"double":   true,
		"fixed32":  true,
		"fixed64":  true,
		"float":    true,
		"int32":    true,
		"int64":    true,
		"sfixed32": true,
		"sfixed64": true,
		"sint32":   true,
		"sint64":   true,
		"string":   true,
		"uint32":   true,
		"uint64":   true,

		// reserved keywords
		"enum":     true,
		"import":   true,
		"map":      true,
		"message":  true,
		"oneof":    true,
		"option":   true,
		"package":  true,
		"public":   true,
		"repeated": true,
		"reserved": true,
		"returns":  true,
		"rpc":      true,
		"service":  true,
		"syntax":   true,
	}
)
